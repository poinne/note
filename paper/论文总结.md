### DMVC 的不足：

1. 相比于传统的方法，压缩和解压缩所用的时间更久。在一些场景中可能不能使用。
2. 实验中1-hop效果要比2-hop效果好，可能是作者用的特征筛选机制不够好，有可以改进的地方。
3. 只与简单的方法进行了比较，没有与当前使用的流行方法进行比较。可能效果并没有当前流行的方法好。
4. 没有对不同的数据集的模型进行测试，不知道模型的泛化能力好不好。

根据你上传的文章《node2vec: Scalable Feature Learning for Networks》中的描述【105†source】，该网络模型使用的是**node2vec**算法。这是一种用于图结构数据的可扩展特征学习框架。

**node2vec的核心要点：**

1. **特征学习**：node2vec通过将节点嵌入到低维空间来学习网络中节点的连续特征表示。其目的是保持节点的网络邻域，即使在降维的特征空间中，仍然能够保留节点之间的相对拓扑关系。

2. **随机游走（Random Walks）**：模型通过执行**有偏随机游走**（biased random walks）生成网络中节点的邻域。与传统的广度优先搜索（BFS）和深度优先搜索（DFS）不同，node2vec能够灵活调整搜索策略，探索图中的不同类型的邻域。

3. **优化目标**：node2vec的目标函数基于最大化节点在邻域中的条件概率，通过优化这个目标函数，生成节点的特征嵌入。优化使用**随机梯度下降（SGD）**进行处理。

4. **任务应用**：该模型可以应用于多标签分类（如节点分类）和链接预测等任务。实验表明，node2vec在多个现实网络数据集上的表现优于现有的特征学习算法。

总结来说，node2vec是一种结合随机游走和图嵌入的强大算法，通过生成灵活的节点表示，能够处理不同类型的网络任务。

### 论文0

**Learning the Geodesic Embedding with Graph Neural Networks**

使用GNN学习测地线嵌入。	

1. 快速预计算
2. 计算离散表面的近似测地距离（GDQ）
3. 可以处理含噪声和不完整的网格（训练时学习到了形状先验）
4. 泛化能力强
5. 通过修改损失函数，该模型还可以用于其它距离的近似。

Unet+GNN的网络架构，作者使用自定义的**图卷积和图池化**模块来搭建Unet网络，将输入的Graph转换为每个节点为256维嵌入的特征图。再通过MLP作为解码器，将输入的任意两个节点嵌入进行解码，输出它们之间的测地距离。

![image-20241020134322634](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241020134322634.png)

**”特点“**

预计算后可以在const时间预测网格上两个任意**顶点**之间的测地距离。

这篇文章虽然是只计算测地距离，但是效果并没有论文2的过拟合模型效果好，误差超过了2%，而论文2的过拟合模型误差只有0.5%（论文2泛化模型MRE超过3%），但是胜在该文章的模型泛化能力强，且可以处理受损的网格。

**解决的问题：**

1. 以前的方法要么精度低，要么需要较长的预计算时间。
2. 之前方法的计算成本至少与顶点数量成线性关系，而我们的方法在推理过程中具有恒定的复杂性。



**关键问题：**

设计图卷积和池化模块，以及测地距离预测的映射函数。（网格的局部几何结构对于测地线嵌入至关重要）



**训练：**

使用ShapeNet 的子集，13类别，24807个网格，80%用于训练，20%用于测试。

将所有网格转换为水密流形，然后各向同性重新网格化。

使用MMP生成gt值，每个网格600K对点。

每次训练迭代中，从训练集选择一组网格，每个网格中从600K对测地数据中选取100K进行训练。

网络模型由两部分组成，第一部分是一个unet-like网络，但是网络中的卷积和池化层都被重新设计，以考虑到网格的局部几何结构。将网格模型以图的形式输入网络，其中，图的每个节点为6维，包括坐标和法向。通过unet后得到包含几何特征的高维特征图，第一部分最后将高维特征图通过FC层转换为高维嵌入向量，用于第二部分。

网络模型的第二部分为一个MLP，使用MLP作为可学习的距离函数，将一对顶点嵌入特征映射到测地距离。

（作者通过一个参数来控制模型最终输出的是测地距离还是嵌入向量，可用于其它距离的学习）

【每次将一个网格输入进unet，通过unet后得到对应的特征图，之后通过该网格对应的100K对顶点进行训练，通过MRE Loss进行梯度反向传播，训练参数】所以最终得到的模型可以处理含噪声和不完整的网格，因为作者使用的unet，最终得到的特征向量图会结合多种尺寸的特征图。

**模块设计**

- 卷积模块

  ![image-20240927162632414](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240927162632414.png)

  受之前文章的启发，max有利于识别代表性元素。

  同时$l_{ij}$可以考虑到顶点之间的局部距离。	

- 池化模块

  ![image-20240927154315109](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904193721994.png)

  考虑对网格的几何结构，为了防止薄面不处于同一个面都是欧式距离近的顶点被合并，池化时会同时考虑顶点的坐标和法向（6D）。并通过两个因子控制：$\sigma_c、\sigma_n$

  在进行池化（下采样）时会就6D空间划分为网格（grids),两个因子控制划分grids的大小。

  在编码模块，每经过一次池化模块，这两个因子都会放大一倍。

  （会记录下顶点在下采样模块前后的映射关系，用于上采样恢复顶点）

**局限性：**

1. 不能很好的处理各向异性的网格，不过可以通过重新网格化来解决。
2. 对于形状在训练集中很少见的网格，MRE较大。
3. 不能很好地满足三角不等式。
4. 

### 论文1

**GraphWalks: Efficient Shape Agnostic Geodesic Shortest Path Estimation**

- 使用图神经网络来预测两点之间的最短测地线距离，以及对应的路径。

过去的方法：

传统方法：bfs、A*、Dijkstra、Ford等，当图变大时，性能会下降。

学习方法：如果图的拓扑不同，则需要重新训练模型。

且上述方法只能提供最短距离，不能给出对应的路径。

**问题：**

1. **测地路径和测地距离这些固有属性，会不会受非刚性变换的影响？**

2. **顶点嵌入层中用到的卷积层的信号是什么？坐标？**

   卷积的对象是顶点坐标，也会用到边，因为是对图进行卷积，每次卷积都是对每个顶点的邻域进行操作

3. **模型如何处理拓扑不同的情况？**

   GNN的图卷积操作是在图的局部区域上进行的，所以可以处理不同的几何和拓扑结构。

   

   


**图A 和图B 的顶点数和邻接关系不同**，但 GNN 处理这两个图的方式是相同的。无论顶点数或邻接关系如何变化，GNN 只根据每个顶点的邻居节点进行局部特征聚合。

**顶点数不同**不会影响输入的通道，因为每个顶点都有相同维度的特征向量，并且卷积操作基于局部邻域的特征聚合，因此 GNN 能处理不同大小的图。

**GNN处理不同几何和拓扑的输入**

GNN处理不同顶点数的图时，通常采用可变长度的输入表示，例如通过邻接矩阵或边列表来表示图结构。这些表示方式允许每个图的大小和形状不同。模型通常使用填充（padding）或动态批处理（dynamic batching）技术来处理不同大小的图。在某些情况下，GNN还可以使用图池化方法，将不同大小的图映射到固定维度的表示，从而实现对不同图的统一处理。



有两种不同的方式计算测地线距离：

1. 将三维多边形网格视为一种图形结构，将测地线距离计算为最短路径段的和。（如Dijkstra）
2. 在离散化可微曲面的假设下，利用可微几何的算法计算测地线距离。
3. 使用学习的方法，如Node2Vec，但是提出的嵌入层不能推广到不同的图拓扑中。
4. 



该论文模型预测方式：

若预测i和j点之间的距离，给定点p作为最短路径的当前输入，使用自回归方式预测最短路径中p+1点的位置

----

使用GNN网络，使用消息传递算子来编码表面的拓扑先验。



**文章解决的问题：**

1. 以前的优化方法，耗时，如果在大的图上进行全对最短路径的计算，需要的用时是非常多的。（文章中提出的模型可以快速的进行测地路径预测）
2. 以前的模型方法，对需要预测的网格的拓扑有要求，需要和训练的一致。否则需要重新训练。（文章中提出的模型可以对拓扑不同的网格进行预测）【GNN可以处理不同的顶点拓扑，之前的文章并没有用GNN】

过去计算测地距离的方法：

1. 将网格看作图，用传统的方法进行计算
2. 在离散可微表面的假设下使用可微几何的算法来计算。

**优点：**

1. 模型可以预测离散网络两点之间的测地路径和距离。
2. 模型的每个模块都是可微的，可以迁移到其它模型中。
3. 模型可以处理不同的网格拓扑。
4. 模型预测的速度很快。

每个模块都是可微的 : 模型的每个模块，包括路径描述、顶点选择、损失计算等，都是使用可微的操作构建的，以支持端到端的训练

**不足：**

1. 预测的路径不能穿过face，只能在edge上。相当于有learning方式查找图中两点最短路径。
2. 预测的准确性不高，测地路径长度误差接近20%（小于5%是可以的，比较好）

**训练过程：**

使用TOSCA数据集，60个网格用于训练，20个网格用于测试。

其中，每个网格包含网格本身的几何和拓扑信息，以及随机采样500对顶点，并通过ford算法得到的测地路径信息。

训练时，首先将网格信息以图的形式进行输入，通过顶点嵌入层对图的信息进行卷积，得到每个顶点的特征向量。然后将测地路径信息作为gt数据监督模型的路径生成。

使用这些路径作为训练数据，模型在训练时实际上学到的是如何在不同的网格上预测测地路径。

---------------------------------------------------------------------------------------------------------------------------



![image-20240925133638505](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904194356748.png)





**模型的三个主要模块**

（三个模块都是可微分的，可以用在任何的学习模型中）

**Vertex Embedding Layer**

使用的是节点之间的相对位置信息，使得网络能够更好地捕捉到3D形状的拓扑结构。

（假设两个点在欧几里得空间中很接近，但它们实际上可能位于3D形状的不同部分上，在表面曲线上可能相距甚远。这时，拓扑结构特征就至关重要了。）

顶点嵌入层的目标是为每个节点分配与拓扑结构相关的特征，而不是生成与拓扑结构无关的顶点特征。

方法：

使用了多层的图卷积层来构建顶点嵌入层。这些卷积层能够通过多次的邻域聚合操作来捕捉节点之间的拓扑关系，从而更好地估计复杂的测地线路径。

节点特征更新操作如下

![image-20240904193721994](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904194313887.png)

聚合函数可以为: [mean, min, max, std].

【通过多次图卷积操作，使最终的顶点特征向量中包含拓扑信息】

**Path Descriptor**

预测的路径偏离目标点，甚至在节点周围形成循环，从而使路径失效。引入了一种路径描述符来编码路径的前缀，即从起点到当前节点的路径信息。

![image-20240904194313887](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240925133638505.png)

$\beta$ 是一个通过sigmoid函数计算得到的权重，用来平衡前一个路径描述符和当前节点特征之间的影响力。

生成包含当前节点的路径的路径描述符：

![image-20240904194356748](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904200717051.png)

在路径预测过程中使用动量公式来确保路径的方向正确，避免产生不合理的路径预测。特别是，目标是确保路径预测不受回路或错误方向向量的影响。

**公式解释：**

- **路径描述符 $g_t $**：表示在第 $ t $ 步时路径的状态，结合了之前的路径信息和当前节点的特征信息。
- **节点特征 $f^t_i $**：表示当前节点 $ v_i $ 的编码，体现该节点在路径中的位置和特征。
- **动量公式**：公式中的动量思想来自于惯性原理，通过当前节点特征 $ f^t_i $ 和前一个时间步的路径描述符 $g_{t-1} $ 的加权结合，来计算当前时间步的路径描述符 $ g_t $。

公式为：
$ 
\beta = \text{sigmoid}([g_{t-1}||f^t_i])
$
这里的 $ \beta $ 是通过前一个路径描述符 $ g_{t-1} $ 和当前节点特征 $ f^t_i $ 计算出的权重，它决定了当前路径描述符 $ g_t $ 中应该有多少来自当前节点的特征，多少来自先前的路径描述符。

接着通过下面的公式更新路径描述符：
$ 
g_t = \beta f^t_i + (1 - \beta) g_{t-1}
$
这个公式说明当前路径描述符 $ g_t $ 是之前路径描述符 $ g_{t-1} $ 和当前节点特征 $ f^t_i $ 的加权平均值。权重 $ \beta $ 通过 sigmoid 函数平滑地结合两者，确保路径的方向和当前预测保持一致。

**当 $s t = 0 $ 时：**

- **$ g_0 $ 的值**：当 $ t = 0 $ 时，公式中的 $ g_{t-1} $ 实际上是 $ g_{-1} $，但 $ g_{-1} $ 通常表示路径的初始状态。在初始状态下，$ g_0 $ 通常被初始化为 0 或与路径的起点相关的某个特征向量。

因此，**当 $ t = 0 $ 时，$ g_0 $** 的值取决于具体的实现方式，常见的做法是将其初始化为 0，表示路径从初始状态开始累积信息。

**总结：**

- **动量公式**结合了当前节点的特征和前一段路径的信息，以确保路径方向的一致性，避免路径偏离目标。
- **当 $ t = 0 $ 时**，路径描述符 $ g_0 $ 的值通常被初始化为 0 或其他初始状态，以便从头开始累积路径信息。

**Point Selector**	

从当前点vi的邻域选择路径中的下一个点。

定义vj在vi邻域内的相对特征为:

![image-20240904195519450](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904195519450.png)

同时考虑源点，目标点，当前点vi，邻域点vj以及vj到目标点的欧式距离。

利用余弦相似度特征来捕捉路径方向及其与起点和终点之间的方向向量的对齐。

选择余弦相似度最大的点。

当前遍历的vj为下一个路径点的概率：



**Loss functions**

为了训练所提出的方法，利用两个目标函数的组合，即点选择器交叉熵损失和概率测地线距离损失。

**点选择器分类损失**

点选择器分类损失的主要范围是使点选择器在路径的每一步中选择正确的下一个点的概率最大化。

使用了二元交叉熵损失，帮助模型最大化点选择器模块的预测概率，使其尽可能接近路径中的真实点。

使用了一种名为“教师强制”（Teacher Forcing）的策略。做法是，在每次预测后，将真实的路径点反馈给模型，而不是让模型基于自己的预测继续进行下去。

**概率测地线距离损失**

通过加权邻居点的选择来最小化每一步的测地距离。

![image-20240904200717051](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904202941410.png)

**使用波束搜索**

为了避免模型“短视”，使用波束搜索，波束宽度k = 3



**训练**

为了训练我们的模型，我们使用了TOSCA数据集[3]，该数据集包含80个不同非刚性变换下的独特形状。由于形状的多样性和它们包含的大量粗糙区域，我们认为TOSCA数据集非常适合测地线路径建模任务。我们随机选择了**60个形状用于训练，20个独特的形状用于测试。为了生成数据集，我们为每个形状随机选择500对顶点**，并使用Bellman-Ford算法生成地面真值路径。

**结果**																																

geodesic distance error (GDE) 

![image-20240904202941410](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904200017753.png)



![image-20240904203016246](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904203016246.png)

收敛性：这些方法选中的路径中路径长度不超过真实路径120%的路径个数。







![image-20240904203332540](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904203904952.png)

![image-20240904203343277](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914165413885.png)









该方法对点云也有不错的效果

通过KNN构建点的邻接关系。（每个点选择5个最近的节点作为邻居）[如果所有的点都是在表面采样的话，得到的路径就是在表面]

![image-20240914164625071](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904203343277.png)





**消融实验**

![image-20240904203904952](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914140039425.png)

**局限性**
所提出的方法高度依赖于神经网络的近似能力，这意味着网络在生成最短路径时的质量直接受到神经网络表现的影响。	在某些极端情况下，比如训练集中未涉及的场景，或者当最短路径不明显时，神经网络的近似能力可能受到限制，从而影响路径的准确性。

![image-20240914165413885](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240913200236964.png)

### DeepSDF

核心思想是将形状建模为由前馈神经网络表示的零等值面（iso-surface）的决策边界，并通过训练网络来学习表示符号距离函数

在过拟合的模型中，形状信息包含在网络本身中，而在编码形状DeepSDF中，会发现每种形状的共同属性并将它们嵌入到低维潜在空间中。得到对应的潜在向量z。

此时，模型的潜在形状嵌入z与查询点x一起作为模型的输入。通过模型得到x的符号距离。

![image-20240914140039425](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240926134906913.png)



### 论文2

**NeuroGF: A Neural Representation for Fast Geodesic Distance and Path Queries**

现有神经隐式表征的工作机制可分为泛化的和过拟合的。

---

首先，这个模型是过拟合的，用隐式方式在单个神经模型中表示3D形状的测地路径和距离。

适用于需要频繁在线查询点对点测地线的应用程序。

网络的尺寸小，参数少(256K)，但是预测的精度很高，相对平均误差小于0.5%（通过过拟合实现）

将测地路径建模为一系列有序3D点的离散序列。



![image-20241020142101762](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241020142101762.png)

背景介绍中，说论文1(GraphWalks)预测精度不令人满意。

思想：

该模型主要用于对同一网格频繁大量查询的情况，通过大量的数据过拟合给定网格，使得模型可以在该网格上达到很高的精度，借助GPU的性能，即可实现快速、高精度的点对点查询。

每个输入网格都需要重新训练一次模型。

训练前：

准备好网格模型对应的大量的点对和对应的测地路径、测地距离数据。

sdf数据集生成：

 使用DGG-VTP 和快速离散测地线图 (fDGG)分别生成gt测地距离和最短路径。

使用网格简化工具QSlim为每个网格采样20K个点进行训练数据生成。

训练过程：

![image-20240926134906913](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914164625071.png)

在每个epoch中，调用方法获取数据，其中路径和距离的gt数据已经事先保存在npy文件中，直接读取即可，sdf数据是在每个epoch中采样，然后调用pcu库生成gt数据的。

训练时用的qt和qs都是网格上采样的顶点。

每次输入一组qt和qs，所	的顶点通过FC层（liner层）编码为高维向量et和es，

测地路径生成：

拼接后通过FC层生成guidance vector，与对应的一组初始的line进行拼接，通过三层MLP得到最终的有序测地路径点序列。（每条line与对应的指导向量拼接后仅经过一次三层MLP即输出，不会迭代进行优化）

测地距离则是直接令et与es相减，取绝对值。再将得到的向量通过FC层得到（标量）。

sdf则是直接通过FC层，得到一个标量值。

训练时会同时处理这三个分支，将所有要查询信息的输入点拼接到一起，一起提升到高维后，再进行切分用于不同的任务。(这样做，训练好的权重参数可以直接用于单任务的模型中)

例如：（一组数据）

拼接后：

查询sdf的输入点（n1 * 3维）、查询测地距离的输入点（n2 * 2 *3维）、查询测地路径的输入点（n3 * 2 * 3维）

得到一个(n1 + 2 * n2 + 2 * n3) * 3维的矩阵。

输入时就只有各种点的坐标数据，通过模型处理后得到测地路径、测地距离和sdf值，与每组坐标点对应的gt值做loss，然后反向传播，优化模型参数。

作者又分别搭建了三个网络结构相同的模型，只是forward不同，用于分别处理每个分支。



虽然采用了sdf损失来约束路径上的点的位置，但是相邻点之间的连线仍有可能穿过面片。文章在最后提到可以用后投影、细化技术，结合sdf 进一步对生成的路径进行处理，使生成的曲线点精确地定位在下垫面上。



---



前一类方法倾向于以较低保真度表示为代价，从大量形状集合中学习可推广的形状先验，而后一类方法旨在通过相应地过拟合单个神经网络模型，以高保真度再现单个形状。

在本文中，我们首先遵循后一种过拟合神经隐式模型的表示范式，即在单个目标网格模型上单独过拟合单个神经网络，以验证我们的神经神经网络的表示能力。然后，我们进一步努力扩展可推广的方案，以学习未知形状和新类别的测地线。

过拟合的神经网络，训练过程如下：

思路：通过数据过拟合一个网格对象M，实现对于任意两个顶点，预测其测地路径和距离。

1. 训练数据生成：
   - 在M随机采样顶点和M表面上的点，以及一些添加了扰动的表面点，通过pcu计算其距离表面的符号距离。将得到的数据点和对应的符号距离作为M的sdf数据集。
   - 提取出模型中的测地线信息，每条信息维7维，包括源点、目标点和距离。
   - 测地路径同理。
   - 在给定网格上训练时不需要每对网格顶点之间的测地线。使用的是顶点的子集。每个输入网格采样20K个顶点。（实验观察到，更多的顶点并没有明显的精度增益）

![image-20240913200236964](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240913190923306.png)

训练时使用的ground true，距离是用DGG-VTP得到的，路径是用fdgg算法得到的    

![image-20240913190923306](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914141039894.png)

![image-20240913154111470](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240913195725866.png)

![image-20240914141039894](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905102530131.png)



chamfer-L1：

Chamfer-L1距离是一种用于比较两个点集的距离度量，常用于计算网格模型或点云模型中不同点集之间的差异。在测地路径的上下文中，Chamfer-L1距离计算测地路径上的点与预测路径上的点之间的距离差异。

![image-20240917160253858](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240917160253858.png)

L1范数和欧式距离（即L2范数）有区别，

**L1范数（曼哈顿距离）**

L1范数，也称为曼哈顿距离，是计算两个点之间距离的一种方法。它的计算方法是对每个坐标轴上的绝对差值进行求和。公式如下：

对于二维空间中的两个点 $ (x_1, y_1) $ 和 $ (x_2, y_2) $：

$ \text{L1范数} = |x_1 - x_2| + |y_1 - y_2| $

对于n维空间中的两个点 $ (x_1, x_2, \ldots, x_n) $ 和 $ (y_1, y_2, \ldots, y_n) $：

$ \text{L1范数} = \sum_{i=1}^{n} |x_i - y_i| $

**欧式距离（L2范数）**

欧式距离，也称为L2范数，是最常见的距离度量方法，它是两个点之间的直线距离。公式如下：

对于二维空间中的两个点 $ (x_1, y_1) $ 和 $ (x_2, y_2) $：

$ \text{欧式距离} = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2} $

对于n维空间中的两个点 $ (x_1, x_2, \ldots, x_n) $ 和 $ (y_1, y_2, \ldots, y_n) $：

$ \text{欧式距离} = \sqrt{\sum_{i=1}^{n} (x_i - y_i)^2} $

**主要区别**

1. **计算方式**：
   - **L1范数**：计算绝对差值的和，适用于城市街道网格布局的距离计算（如曼哈顿街道网络）。
   - **欧式距离**：计算直线距离，适用于计算两点之间的“直线”距离。

2. **几何意义**：
   - **L1范数**：度量的是沿坐标轴方向的距离，形成的距离度量是一个正方形网格。
   - **欧式距离**：度量的是最短的直线距离，形成的距离度量是一个圆形网格（在二维空间中）。

3. **鲁棒性**：
   - **L1范数**：对异常值（outliers）相对不那么敏感，因为它只计算绝对差异。
   - **欧式距离**：对异常值更敏感，因为平方差会放大极端值的影响。





![image-20240913195725866](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914110754051.png)





修改后的模型：

![image-20240914141128804](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905110609517.png)

对比过拟合的模型，主要变化是多了一个global descriptor的向量，将这个向量与查询点进行拼接。这个描述全局特征的向量可以通过三种方式得到：

1. autodecoder：主要是通过自编码器将网格模型的形状信息编码到一个潜在向量中，多个不同的模型会编码维不同的潜在向量，模型其余参数保持不变，根据潜在向量的不同，模型的输入也会不同。
2. point cloud：通过KNN对点云数据进行特征卷积操作，经过多次卷积得到网格模型的全局信息。
3. 通过GNN的图卷积操作进行全局拓扑信息的获取。

代码中通过一个读取网格模型的mv、mf、pointCloud信息，以及源点、终点、测地距离。将这些信息保存在一个数据对象中。

​	训练代码中主要展示了对点云的操作，定义了一种点云卷积操作，通过KNN算法以及事先定义的每个点的邻居数量，获取到每个点的邻域信息，并进行特征拼接。



泛化后的模型只能对测地距离进行预测，无法处理测地路径。

"能力并没有比之前的好，但是差距不大"(论文中说的)



![image-20240914110754051](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905110546548.png)



在离线训练阶段，采用监督学习方法对神经网络在特定形状上进行过拟合。过拟合过程完成，可以有效地计算任意的点对点测地线的查询。通过一次前向传递过程。

![image-20240905102530131](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905111936737.png)

神经网络架构由三个并行学习分支组成，可以并行计算最短测地线路径、最短测地线距离和带符号距离字段。

三个分支相互独立，没有特征融合或传播，所以避免只需要对某一信息进行预测时进行冗余计算。







**最短测地线距离**

距离的预测被建模为源点和目标点嵌入的向量差的绝对值，通过三个FC层进一步映射为测地线距离的标量值。

![image-20240905110546548](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240913154111470.png)![image-20240905110609517](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905112228854.png)

**最短测地线路径**

模型从源点到目标点的直线段(基准线段)开始，然后通过可学习的引导向量引导这个直线段变形成目标3D曲线。

步骤：

1. 直线段的初始化：首先，在源点和目标点之间采样M个等间隔的3D点，形成一条初始的直线段。这些点将作为初始曲线的基准。

![image-20240905111936737](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905113725696.png)

​        可以通过调整m来控制曲线上点的密度。

2. 特征引导向量的计算：接下来，模型通过源点和目标点的特征嵌入生成一个“引导向量”，这个向量决定了直线段如何变形成最短路径。

   ![image-20240905112228854](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905131629802.png)

   h是映射函数（实现为mlp），[\*;\*]表示对通道进行连接。

3. 曲线变形：将这个引导向量附加到初始直线段的每个点上，生成一个特征矩阵，然后通过多层感知机（MLP）对每个点进行逐点变形。最终输出的是一条经过变形后的3D曲线，这条曲线就是源点和目标点之间的最短路径。

   ![image-20240905112444939](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905112444939.png)

   $[g_{s\rightarrow t};l_{s\rightarrow t}]$维度为$D_e + 3$, $B_{spath}$由四个逐点FC组成，最后一层的输出维度为3。

**带符号距离(辅助）**

以查询点的**特征嵌入**作为输入，生成对应的符号距离值（标量）。

![image-20240905113725696](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905131722451.png)

 $B_{sdist}$由三个层的FC组成最后一层的输出维度为1。



**学习目标**

- 测地线距离： 

  ![image-20240905131629802](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905131708676.png)

- 测地线路径：

  ![image-20240905131708676](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905131936177.png)

- 符号距离：

  ![image-20240905131722451](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905132740224.png)

- 曲线长度的一致性约束:

  预测的路径和实际路径的曲线长度差：

  ![image-20240905131936177](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905135620500.png)

  这里的曲线长度近似为相邻点之间的成对欧几里得距离的和。

- 曲线点的分布约束：

  通过最小化其带符号距离的绝对值来进一步约束生成的曲线点的空间分布。减小生成的测地线曲线与相应的形状面之间的偏差。

  ![image-20240905132740224](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240914141128804.png)

**模型参数**

![image-20240905135603136](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905135603136.png)

![image-20240905135620500](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905135628446.png)

![e'e'e](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905143622076.png)



**泛化模型的设计**

 

![image-20240905143106425](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905143106425.png)

结果如下：

1. SN-Airplane、SN-Chair和SN-Car是在飞机、椅子和汽车的同一类别中收集的，每个类别包含500个模型。

2. SN-8x50是从与训练集相同的8个类别中收集的，但每个形状在训练时是不可见的。

3. SN-5x50从其他5个不同的类别中收集。

![image-20240905143622076](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905133717769.png)

**实验结果**

![image-20240905133717769](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905133504444.png)

$\tau$代表各向异性的程度，其中$\tau > 3$被归类为各向异性模型。

![image-20240905133504444](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907101816176.png)

fDGG精度参数$\epsilon$ = 2.5%,前三个在i5 7500上运行，NeuroGF在3090上运行。

![image-20240905142143258](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907102739791.png)

可视化比较

![image-20240905142332586](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905142143258.png)

尽管NeuroGF在测地距离查询和SSAD（单源全目标最短路径问题）上表现优异，但生成的测地路径并不一定严格位于3D形状的表面上。由于神经网络的拟合性质，路径中的一些点可能会偏离真实的表面，导致路径在几何上出现误差。





### 论文3



**问题：**



1. 这个函数为什么是可微的？

   测地路径虽然一般不是端点的平滑函数，但是测地距离是处处C0连续的，通过两种导致函数不连续的情况，一种可以在最小化的过程的避免。第二种情况可以通过优化，测地距离可以达到C2连续。因此该函数可以得到二阶导数。

2. 这个函数的作用是什么？

   计算离散表面上的测地距离。

   提出了一种可微的测地距离公式，该公式几乎处处 C2 连续，并且在集成到牛顿型最小化算法中时表现出鲁棒的收敛性。

3. 设计这个函数的目的是什么？

   在一些需要使用测地距离的场景中，使用该函数，可以用二阶下降方法来对问题进行优化。

4. 这个可微函数为什么要这么设计？

   虽然测地路径不是连续的，但是测地距离至少的C0连续的，将一些不够光滑的情况处理后，测地距离可以达到C2连续。因此可以计算测地距离的一二阶导。

   计算测地距离时，需要考虑路径与边的交点，并且当端点发生改变时，需要显示的跟踪所有的交点，交点的数量和位置都会发生改变，复杂度高，不可行。

   所以作者提出使用端点作为测地距离函数的显式变量，计算导数时只需要考虑端点的变化即可。交点和端点的关系通过MMP算法隐式表示。

- 离散背景下，最短路径和最直路径并不一致。【不理解】

  **最短路径**在离散网格上确实通常是沿着网格的边走，因为网格的顶点和边构成了自然的离散几何结构。通过顶点连接的路径可以定义为"最短路径"，因为它们依赖于网格的图结构，常常通过图论中的最短路径算法（如Dijkstra算法）计算出来。这种路径不会真正"穿过"面片，而是通过网格的边到达目标点。

  **最直路径**，则并不局限于沿着网格的边走，而是更注重保持方向的连续性。尽管在离散环境中，表面由面片构成，它的"直性"更接近于在每个面片上走直线的方式。**最直路径**会在每个三角形面片的内部形成直线段，并且在面片之间的交界处进行方向的平滑转移。这种路径会穿过面片的内部，而不只是沿着边缘行走。

  对于端点已知的边值问题，最短路径定义是一种自然选择，而对于具有给定起点和切线方向的初值问题，最直路径定义是最适合的。

- **奇异构型**是测地线突然改变方向的情况。

  奇异构型指的是一种**路径发生突变**的情况。在测地线上，两点之间的路径可能不是唯一的。虽然测地距离是连续的，但路径本身可能在某些构型下突然发生变化。例子：上方的终点缓慢移动时，原来的路径突然“翻转”，转向了不同的方向。这种情况即为奇异构型。

- **距离导数**指的是**测地距离关于点的位置变化的导数**。它反映了当一个点轻微移动时，距离变化的速率。在奇异构型中，虽然两点之间的距离是连续的，但路径突然变化的现象会导致**距离导数的不连续**。

  在这些奇异构型中，路径可以突然改变方向，导致距离导数在翻转路径的瞬间产生跳跃。换句话说，当路径突然从一条切换到另一条时，距离的变化速率也会发生突变。因此，距离导数在这些点必然是不连续的。

- 切割轨迹（Cut Locus）是指从给定点出发，所有其测地线不唯一的点的集合。也就是说，当你从某个点出发时，如果到达某个点的测地线不止一条，那么这些点就构成了切割轨迹。

  尽管距离的梯度在切割轨迹上是不连续的，甚至沿着切割轨迹，路径的梯度未定义，但**这并不妨碍基于梯度的最小化过程**。因为在切割轨迹上的点，测地距离是局部最大的，即在这些点上距离不会再变短。因此，虽然梯度无法定义，优化算法仍可以正常工作，并最终找到局部最优的测地线。



论文的目标是使用二阶优化器最小化三角形网络上基于距离的函数。【需要距离度量足够平滑且可微分】

欧式距离在三维离散网格上会不准确，因此使用测地距离

**测地距离的平滑度：**

两点之间的测地距离是表面上各处点的连续函数。然而，测地线路径并不总是唯一的，并且可能会突然改变以实现端点的平滑运动。在这些奇异配置中，距离导数必然是不连续的。

![image-20240907101816176](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907103837884.png)



尽管切割轨迹上存在梯度不连续的现象，但由于这些不连续点通常是局部极大值，而非全局极值，梯度下降法仍能有效工作，通过跳过这些不连续的极大值点来找到最终的最短路径。最优化过程仍然不会中断。



测地线靠近网格顶点时有三种情况：

**正曲率顶点**：测地线不会经过该顶点，路径可能在此处不连续（C0连续），但路径避开了这些顶点。
**零曲率顶点**：测地线为直线，欧几里得距离，可以认为是最简单的情况。

**负曲率顶点**：测地线可以连续通过这些顶点，但局部切线方向会发生跳跃，因此只有 C1 连续性，通过平滑处理可以恢复更高阶的连续性。（达到C2连续）

![image-20240907102739791](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907104202166.png)



虽然测地路径通常不是其端点的连续函数，但它们的长度连续变化，因此可以用于基于梯度的最小化。

然而，计算所需的导数并非易事。三角形网格上的测地线通常跨越多个面并与宿主曲面的边缘相交。显式跟踪不同数量的交集变量很麻烦。**使用端点作为自由度**可以避免这个问题，但交点是端点的函数，为一阶和二阶导数的计算增加了另一层复杂性。事实上，我们不知道有任何现有的工作可以计算三角形网格上测地距离的解析导数。接下来，我们开发了**一种可微的测地距离公式，其一阶和二阶导数可以有效计算**。由于我们的公式仅需要内在量，因此我们将其称为内在最小化

【在几何和优化问题中，**内在量（intrinsic quantities）**是指不依赖于外部坐标系或嵌入空间的量，它们只依赖于物体本身的结构或几何属性。就三角网格上的测地线距离问题而言，内在量通常是指与曲面或网格本身的几何性质相关的量，而不是依赖于其在三维空间中的具体位置或形状。

具体到你提到的内容中，内在量指的是与三角网格上测地线距离的计算和优化相关的量，比如距离、角度和路径长度，它们只取决于网格的拓扑结构和面内几何性质。这意味着，无论这个网格如何在三维空间中弯曲、扭转或者变形，只要网格的连接关系保持不变，这些内在量也不会改变。

**内在最小化（intrinsic minimization）**就是基于这种内在量进行的优化。与此相对，外在量（extrinsic quantities）会依赖于三维空间中的具体嵌入，例如顶点的三维坐标或网格的表面曲率。】



**公式的定义**

这个公式在三角网格上是可微的。该方法只使用测地线的两个端点作为显式的变量，而不需要显式处理路径中间的交点。

测地路径上与三角网格边相交的点并不是直接计算出来的，而是通过最短路径能量泛函的平衡条件隐式地定义。这种隐式处理减少了计算的复杂度。

![image-20240907103837884](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907105930022.png)

首先在robust MMP algorithm基础上计算三角形网格上的精确测地路径。

测地线路径的端点使用所在三角形的重心坐标表示。

测地线路径和edge的交点使用如下方法表示(t为标量参数）：

![image-20240907104202166](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907104438501.png)

则端点$c_0,c_1$的测地距离为：

![image-20240907104438501](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240905142332586.png)

因为测地线端点c可以通过重心坐标$w$的线性表达得到，交点变量t的关系有MMP算法隐式给出。所以重心坐标$w$是唯一的变量。

![image-20240907105930022](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907110034263.png)

**表达式的导数**

- 一阶导

  ![image-20240907110034263](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907110341952.png)

  当测地距离最小时，内部顶点x满足最优性条件：

  ![image-20240907110341952](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907110502036.png)

  我的理解是：	

  此时一阶导为：

  ![image-20240907110502036](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907111204259.png)

  

- 二阶导

![image-20240907110045780](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907111837804.png)

展开式中，除了$\frac{\partial t}{\partial c}$，其它项都可以代数求值。



用隐式方法求$\frac{\partial t}{\partial c}$

。。。

此时二阶导为：

![image-20240907111204259](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907112048496.png)





**对t的平滑处理**

当测地线经过顶点时，t = 0或t = 1,此时距离函数的导数可能是不连续的，需要进行处理。

![image-20240907111837804](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240907113528674.png)

当t非常接近0或1时，通过三次函数使其平滑地过渡到0，防止其在0或1处突变。

![image-20240907112048496](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908104940090.png)



**距离公式的应用**

1. **嵌入弹性结构**与三角网格的**双向耦合**：例如，模拟弹性物体在曲面上的行为，利用测地线的长度和方向作为弹性物体变形的约束条件。

2. **任意三角网格上的Karcher平均**：Karcher平均是一种在几何上求解“中心”的方法，作者利用他们的可微测地线方法来优化这种平均。

3. **可微测地Voronoi图**：在三角网格上创建Voronoi图，并且通过可微性来进行进一步的优化，例如形状调整。

- Karcher Means.

  ![image-20240907113528674](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908110452214.png)

  将距离公式用于求黎曼质心的变分公式，可以用二阶方法更快速的找到质心。

  之前的方法通过一阶方法来最小化这个能量，现在可以用之前定义的g（测地线距离函数）的二阶导数，通过牛顿法来进行优化，提高收敛性。

- Differentiable Geodesic Voronoi Diagrams







- 不足之处

  我们提出了一种新颖的可微测地距离公式，用于三角形网格的内在最小化。通过将隐函数定理应用于最短路径测地线的变分公式，我们证明可以获得并显着简化封闭形式的一阶和二阶导数，从而允许使用牛顿型最小化求解器。我们使用我们的方法来最小化一组不同的目标，包括嵌入式弹性结构与宿主几何结构的双向耦合、任意三角形网格上的 Karcher 均值以及可微测地线 Voronoi 图。

  虽然我们的内在最小化范式能够在许多嵌入弹性的情况下实现稳健的二阶优化，但在几乎所有情况下，测地线都处于张力下，并且能量随着测地线长度的增加而增加。然而，当测地线受到压缩并且增加长度在能量上有利时，沿切割轨迹的局部距离最大值可能会导致收敛失败。

  我们使用 MMP 算法的开源实现来计算测地距离。虽然我们主要并行执行此计算，但它仍然是我们方法的计算瓶颈。虽然我们基于测地边长度的三角形单元有望用于模拟嵌入式弹性膜，但随着每个单元内的曲率的增加，近似精度会降低

  - **测地线的张力问题**：在大多数情况下，测地线受到了张力的影响，即测地线越长，能量就会增加。然而，当测地线受压缩时，情况就相反，增加长度反而可能降低能量。这时可能会出现局部距离的最大值，导致优化过程**不收敛**。

  - **测地距离的计算瓶颈**：作者使用了一种开源的MMP算法来计算测地距离，虽然可以并行处理，但它仍然是计算中的主要瓶颈。

  - **近似精度与曲率问题**：当嵌入在网格中的弹性结构具有较大的曲率时，基于测地线长度的三角形元素的近似精度会下降。使用更密集的测地三角剖分可以在一定程度上缓解这个问题，但加入内部的积分点和更多的自由度可能是改进的方向。

### 论文4

这篇论文主要是单智能体和多智能体在3d空间中轨迹规划问题。

论文通过神经网络来隐式表示轨迹，并生成符号要求的轨迹。

1. 作者设计了三个loss 函数，考虑障碍、多轨迹的碰撞以及性能（路径长度）三个方面，用于轨迹优化和模型训练。
2. 作者设计了一个优化算法使用这三个loss，结合A*算法进行训练数据的生成。
3. 训练模型：输入4d数据，首先生成初始轨迹，然后通过神经网络结合loss（4个）对轨迹进行优化，（优化后的轨迹可以使用优化算法或其它模型进行二次优化）
4. 模型预测：输入4d数据，首先生成初始轨迹，轨迹点放入CoordinateEmbedder生成高维嵌入，（这里类似于transformer的位置编码，可以捕捉轨迹中时间和空间的位置信息），通过transformer进行优化，FC层将高维轨迹信息转换为4d轨迹坐标。

模型设计：

1. **输入与输出**：
   - 该模型的输入是一组 $ N $ 个智能体的起点和终点位置（$SG_j$)，以及对应的正则化项($W_j$)
   - 输出则是 $ N $ 条对应的4D轨迹。4D轨迹包含时间和空间信息，时间是轨迹中每个点的时间戳，空间是该点的三维坐标。

2. **轨迹提议步骤**：
   - 首先，模型为给定的起点和终点生成一组初始的4D轨迹。
   - 这里采用了一种简单的**线性插值**方法。沿着起点 $ s $ 和终点 $ g $ 之间的直线，等间隔地采样 $ T $ 个离散的三维点：
     $
     l_{s \to g} = p_j = s + \frac{(g - s)}{T} \times j \quad \text{其中} \, j = 0, 1, ..., T
     $
     这条线 $ l_{s \to g} \in \mathbb{R}^{(T+1) \times 3} $ 作为初始路径。
   - 接着，在时间范围 $ [0, T] $ 内均匀分布时间戳 $ \{t_0, t_1, ..., t_T\} $，并将这些时间戳与路径点 $ p_j $ 结合，形成完整的轨迹提议：
     $
     L_{s \to g} = \{(t_j, p_j)\}_{j=0}^T
     $
   - 其他轨迹提议方法也可以使用，例如在文中提到的第 IV-D 部分，展示了将其他方法生成的轨迹或单智能体神经轨迹模型生成的轨迹作为初始输入。

3. **轨迹嵌入（Embedding）**：
   - 生成的4D轨迹被输入到一个**坐标嵌入器（CoordinateEmbedder）**中，目的是将这些轨迹转换为高维嵌入表示。
   - 这个坐标嵌入器使用了**位置嵌入**的方法，类似于Transformer模型中的位置嵌入机制：
     $
     E_l = \text{CoordinateEmbedder}(L_{s \to g})
     $
   - 这些嵌入表示帮助模型捕捉轨迹中时间和空间的位置信息。

4. **Transformer模型的应用**：
   - 坐标嵌入之后，将嵌入向量输入到**Transformer模型**中。
   - Transformer通过**交叉注意力机制**（Cross Attention Mechanism）来捕捉不同轨迹之间的关系，从而生成更加准确的轨迹。
   - 在Transformer的输出阶段，应用一个全连接层将高维向量序列转换为4D坐标序列，形成 $ N $ 条智能体的最终轨迹：
     $
     f_\Theta = \text{FC}(\text{Transformer}(E_l))
     $
   - 每条轨迹的时间范围为 $ T $，为 $ N $ 个智能体生成的最终4D轨迹集。

5. **静态环境与未来扩展**：
   - 该模型的设计重点是在**静态环境**下生成轨迹。
   - 作者指出，未来工作可以通过添加感知嵌入（perception embedding context）来将该框架扩展到动态环境中。

模型训练：

使用ground truth轨迹数据和一些额外的附加正则化项进行训练（如无碰撞和性能指标）



**损失函数：**

- Ground Truth Supervision

![image-20240908104940090](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908105656345.png)

​		逐点计算预测值与真实值的轨迹损失

- Environmental Safety Loss

- ![image-20240908104940090](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908105656345.png)

  使轨迹点到障碍的距离大于阈值$S_{thresh}$

- Inter-Trajectory Conflict Loss

  ![image-20240908110452214](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908110937287.png)

​        确保两条轨迹的任意两个轨迹点之间的距离至少间隔 $w_{thresh}$

- Performance Loss

  ![image-20240908110937287](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908110957795.png)

  确保模型生成的轨迹长度优于或接近真实轨迹的长度。（为什么是生成的比真实的长，而不是短）

- 最终loss为：

  ![image-20240908110957795](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908130219021.png)





模型生成过程

![image-20240908130219021](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908131919355.png)

**输入**：起点和终点的位置。这些位置作为模型的初始输入。

**初始4D轨迹提议**：根据输入的起点和终点，模型提出一条初始的4D轨迹（这里的4D可能表示位置坐标和时间或速度等其他维度）。初始轨迹可以是直线，也可以是由模型提出的轨迹。

**嵌入与生成**：输入的轨迹通过不同的网络层处理，包括：

- **坐标嵌入器**：对轨迹坐标进行嵌入，将其转换为模型可理解的格式。
- **Transformer**：用来处理序列数据的神经网络结构，这里用来优化轨迹。
- **全连接层**：用于进一步的轨迹优化和特征提取。

**生成4D轨迹**：经过网络层的处理，最终投射出生成的4D轨迹。



模型训练过程

![image-20240908130906713](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908130906713.png)

**输入**：模型同样从起点和终点开始输入，首先生成直线作为初始轨迹。

**轨迹生成器（Trajectory Generator）**：初始的直线轨迹通过轨迹生成器，生成优化后的轨迹。

**损失计算**：生成的轨迹与**真实轨迹（Ground Truth Trajectories）**进行对比，损失通过以下几个部分计算：

- **环境安全损失（Environmental Signed Distance Loss）**：确保轨迹远离障碍物，保证安全。
- **轨迹间损失（Inter-Trajectory Loss）**：确保多条轨迹之间保持合理的距离，避免交叉或过于接近。
- **性能损失（Performance Loss）**：确保生成的轨迹在长度等性能指标上优于真实轨迹。
- **真实轨迹损失（Ground Truth Loss）**：确保生成的轨迹与真实轨迹接近。

**损失回传（Loss Backward）**：通过反向传播将损失反馈给模型，以优化生成轨迹的过程。

**训练损失（Training Loss）**：将所有损失项结合，形成最终的训练损失，指导模型更新参数。



**神经轨迹推断：**

![image-20240908131919355](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908132256977.png)

神经轨迹预测有两个主要步骤和一个可选步骤，主要步骤分别是根据输入的坐标生成初始的轨迹，以及通过神经网络对轨迹进行优化。

使用可选步骤进一步对轨迹进行优化（可以用其它的优化网络或算法2）

除了以起始位置和结束位置作为输入外，还可以以有冲突的多条轨迹作为输入，生成无冲突的优化轨迹。





**轨迹优化的算法如下：**

![image-20240908132256977](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240908140320950.png)

损失函数 J(W)是所有轨迹点的一个函数，即：包括环境安全损失、轨迹间碰撞损失、性能损失

通过对J求4d坐标点w的偏导，使用梯度下降法来更新轨迹

![image-20240917203435273](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240917203443912.png)

![image-20240917203443912](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240917203435273.png)

**训练数据的生成：**

首先在给定的环境中采样一些点（路径的两个端点），然后通过A*算法生成初始的轨迹，之后通过算法二进行优化。将优化后的轨迹和两个端点放入数据集中。

算法如下：

![image-20240908140320950](https://raw.githubusercontent.com/poinne/md-pic/main/image-20240904203332540.png)



### 论文5

`紫色说明没看懂、绿色说明看懂了、红色说明很重要`

**[2024_CAGD_]Splines on manifolds_A survey**	

**测地曲率：**

测地曲率衡量的是曲线相对于流形自身的偏移，而不考虑曲线为了保持在流形上而做出的弯曲程度。

测地曲率指的是曲线相对于流形的“漂移”程度，即**曲线在流形上偏离直线的部分**。换句话说，它只关心曲线在流形内的弯曲，而忽略嵌入的外部空间的弯曲程度。

**完备邻域：**

**totally normal neighborhood**

这是黎曼几何中的一个数学概念。一个“**totally normal neighborhood**”指的是在这个区域内，任意两点之间的最短路径（称为“测地线”）都是唯一的。更重要的是，这些最短路径不仅存在，还具有很好的性质：它们的变化是非常平滑的。这种平滑性可以用$“C^{\infty}”$来描述，表示这些路径对起点和终点的依赖是无限可微的，即没有尖角或突变。



这个段落介绍了**指数映射（exponential map）**、**正规邻域（normal neighborhoods）**和**凸集（convex sets）**等概念，它们与曲面（流形）的几何结构、切点集以及测地线相关联。以下是逐步解释：

1. **指数映射与测地线**：
   - 给定一个点 $ p $ 在曲面 $ \mathcal{M} $ 上，以及 $ p $ 的切空间 $ T_p \mathcal{M} $ 中的向量 $ v $，存在唯一的测地线 $ \gamma_v $，其满足 $ \gamma_v(0) = p $ 且 $ \dot{\gamma_v}(0) = v $。换句话说，沿着 $ v $ 方向从点 $ p $ 出发，有唯一一条测地线。
   - 指数映射 $ \text{exp}_p \colon T_p \mathcal{M} \to \mathcal{M} $ 将向量 $ v $ 映射到测地线 $ \gamma_v(1) $ 所到达的点。即，指数映射告诉我们，沿着测地线 $ \gamma_v $ 走一段长度为 $ |v| $ 的距离后会到达哪个点。

2. **正规邻域和对数映射**：
   - 对于曲面上的任意一点 $ p $，存在一个点 $ 0 $ 附近的邻域 $ V \subset T_p \mathcal{M} $，使得指数映射 $ \text{exp}_p $ 可以将 $ V $ 光滑地映射到 $ p $ 周围的一个邻域 $ U \subset \mathcal{M} $。这个 $ U $ 被称为 $ p $ 的**正规邻域**。
   - 在这个邻域 $ U $ 内，指数映射有反函数，称为**对数映射（logarithmic map）**，记为 $ \text{log}_p $。对数映射给出了从点 $ p $ 到达 $ U $ 中任意一点 $ q $ 所需的方向和距离。

3. **正规邻域的性质**：
   - 一个点的正规邻域不能与其切点集相交。在正规邻域内，测地线从点 $ p $ 呈辐射状发出；但离开正规邻域后，测地线的行为可能变得不再直观和有序。
   - 通过限定可行走的最大距离，可以定义**测地球**和**测地正规球**。测地球是以点 $ p $ 为中心，半径为 $ \rho $ 的球体，且其半径的上限为点 $ p $ 到其切点集的距离，这个距离称为**注入半径（injectivity radius）**。

4. **全正规子集和凸集**：
   - 一个开子集 $ U \subset \mathcal{M} $ 称为**全正规子集**，如果存在 $ \delta > 0 $，使得以 $ U $ 中所有点为中心，半径为 $ \delta $ 的球体都是正规球，并且 $ U $ 被包含在这些球体的交集中。
   - 一个子集 $ U $ 称为**凸集**，如果 $ U $ 中任意两个点 $ p $ 和 $ q $ 之间的最短测地线在曲面 $ \mathcal{M} $ 上是唯一的，并且完全位于 $ U $ 内。注意，如果 $ U $ 是凸的，那么它也是全正则的，但反之不成立。

5. **高斯曲率与注入半径的关系**：
   - 曲面的注入半径与其高斯曲率相关。一个区域的最大曲率越高，则该区域内全正规集或凸集的范围就越小。
   - 因为许多流形样条的定义依赖于控制点位于全正规或凸集内，这意味着这些样条的应用受到限制，尤其是在表面粗糙的情况下，适用的邻域可能会非常小。

总之，指数映射、正规邻域和凸集的概念帮助我们理解在曲面上如何定义和计算测地线，并揭示了这些结构在实际应用中可能带来的挑战。

**欧式空间是一个流形**

**流形**是一个局部类似于欧式空间的数学结构，换句话说，它在每一个小范围内看起来像欧式空间，即可以用欧式空间中的坐标系统来描述。欧式空间是流形的一个特例，它不仅局部看起来像欧式空间，而且它就是欧式空间整体上具有的属性。

为什么欧式空间是流形？

- **局部性质**：流形的定义要求在每个点附近存在一个开集，该开集可以通过坐标系映射到欧式空间。欧式空间中的每个点周围的区域本身就是一个欧式空间的开集，所以它满足局部性质。
- **全局性质**：流形可以是局部欧式的，但它不一定整体像欧式空间。然而，欧式空间整体上也是欧式的，所以它不仅满足局部性质，还具备全局欧式的结构。

例如，$ \mathbb{R}^n  $（$ n $-维欧式空间）本身就是一个 $ n $-维的光滑流形，因为它可以在全局上由自身的坐标系统来描述，不需要任何额外的复杂结构。



**通过仿射平均定义样条**

这句话的意思是：在欧几里得空间中，定义样条曲线的最简洁方式是通过**仿射平均**。仿射平均指的是根据权重将多个控制点进行加权平均，从而生成一条曲线。

我们可以通过一个简单的二维空间中的例子来理解：

**例子：**

假设我们有三个控制点 $ P_1 = (0, 0) $, $ P_2 = (1, 2) $, 和 $ P_3 = (3, 0) $。我们想要通过这些点来生成一条样条曲线。

在欧几里得空间中，曲线上的任意一点可以通过控制点的加权平均来生成。例如，给定一个参数 $ t \in [0, 1] $，我们可以根据每个控制点的权重来计算曲线上的点。

曲线 $ s(t) $ 可以表示为：

$
s(t) = (1-t)^2 P_1 + 2t(1-t) P_2 + t^2 P_3
$

这是一个二次贝塞尔曲线公式。具体解释如下：
- $ (1-t)^2 $ 是第一个控制点 $ P_1 $ 的权重，它随着 $ t $ 的变化而减小。
- $ 2t(1-t) $ 是第二个控制点 $ P_2 $ 的权重，当 $ t $ 接近 0 或 1 时，权重减少，在中间时权重最大。
- $ t^2 $ 是第三个控制点 $ P_3 $ 的权重，随着 $ t $ 增加而增加。

通过这种加权的仿射平均，随着 $ t $ 的变化，曲线上的点从 $ P_1 $ 平滑地移动到 $ P_2 $，再到 $ P_3 $。

**小结：**

在欧几里得空间中，仿射平均就是对控制点根据权重进行线性组合，这种方式可以用来构建样条曲线。这种方法非常直观且易于实现，也是样条曲线在欧几里得空间中的基本定义方式。



**Log-exp方法依赖于流形的对数映射和指数映射，通过将点在流形上局部地映射到切空间进行运算，再通过指数映射回到流形上。这种方法在操作时，始终保持对流形的内在几何结构的尊重**。

这段话的核心是在解释**log-exp方法**如何通过流形的**对数映射（log）**和**指数映射（exp）**来处理几何运算，并且保持了流形的内在几何结构。

**1. 局部映射到切空间是什么意思？**

   - 在流形上，流形本身是一个弯曲的空间，而在每一点的**局部**，可以找到一个与该点“相切”的线性空间，这个空间叫做**切空间**。  
   - **局部映射到切空间**，指的是通过对数映射（log），将流形上的点映射到某个特定点的切空间中进行运算。这个特定点通常是一个“参考点”或称为“基点”（通常是我们要处理的点附近的点）。

**2. 什么是切空间？**

   - **切空间**（Tangent Space）是线性空间的一种，它与流形上的某个点“相切”，可以理解为流形在该点的**局部平坦化**。
   - 直观来说，如果我们考虑地球表面（它是一个球面流形），在地球上的某一点（比如你现在站着的地方），切空间就像是你脚下的一块平坦的地面。虽然地球是弯曲的，但在你的站立点附近，这块平坦的区域可以近似地代表地球的局部结构。
   - 切空间本身是一个**线性空间**，类似于我们熟悉的欧几里得空间（比如平面），可以使用标准的线性代数工具在其上进行计算，例如向量加法、标量乘法等。

**3. 为什么log-exp方法可以保持流形的内在几何结构？**

流形是弯曲的，在流形上进行几何运算不能像在欧几里得空间中那样简单。而log-exp方法通过切空间在以下方面保持了流形的几何结构：

1. **对数映射（log）**：  
   - **log映射**将流形上的点映射到切空间中。这个操作可以理解为将流形上的弯曲结构转换到局部的平坦空间里，使得我们能够在一个线性空间（切空间）中进行简单的几何运算，比如点的差、加法等。
   - 由于log映射是在流形的局部定义的，它确保了映射到切空间中的点能够忠实地反映流形的几何性质。

2. **在切空间中的运算**：
   - 在切空间中，我们可以使用线性代数中的运算（比如向量的加减）来处理流形上的几何问题。在这个阶段，我们暂时忽略了流形的弯曲特性，因为切空间是线性的，便于计算。
   
3. **指数映射（exp）**：  
   - 完成了在切空间中的运算后，**exp映射**将结果从切空间映射回流形上。这是一个逆过程，它将切空间中得到的结果重新转换为流形上的点，并且这个映射是基于流形的几何结构定义的。
   - **exp映射**的作用是保证最终的计算结果仍然保持在流形上，从而使得运算结果仍然符合流形的几何特性。

**4. 为什么这样可以保持流形的内在几何的尊重？**

- **log-exp方法**是在流形的局部进行操作，通过切空间避免了直接在复杂的流形上计算的难题，同时使用**对数映射**和**指数映射**保证了转换前后运算与流形几何结构的一致性。
- 因为每次映射到切空间时都是在**局部进行近似**，而不是全局改变流形的性质，所以这种方法确保了流形的内在几何（即弯曲结构、距离测度等）被忠实地保留在计算结果中。
- **总结**：通过在局部的切空间中进行运算，再回到流形上，这种方法既能简化计算，又能保持对流形内在几何结构的尊重，因为整个过程中始终考虑了流形的局部几何特性。





上确界（supremum，记作 sup⁡\supsup）和最大值并不完全相同，但在某些情况下它们可能是相同的。具体解释如下：

- **最大值（maximum）**：如果一个集合有最大值，意味着集合中的某个元素是该集合中所有元素的最大者。也就是说，最大值是集合中的一个具体元素。例如，对于集合 {1,2,3}\{1, 2, 3\}{1,2,3}，最大值是 333。
- **上确界（supremum）**：上确界是所有比集合中任何元素都大的数中的最小一个，也就是说它是集合的最小上界。上确界不一定是集合中的元素。对于具有最大值的集合，最大值就是上确界；但是对于某些集合，虽然它没有最大值，但上确界仍然存在。例如，集合 (0,1)(0, 1)(0,1) 中没有最大值（因为 1 不属于集合），但它的上确界是 1，因为 1 是比所有集合中的数都大的最小值。

所以：

- 如果一个集合有最大值，那么最大值和上确界相等。
- 如果集合没有最大值，那么上确界仍然存在，但它不一定是集合中的元素。

