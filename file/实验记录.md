# 实验记录

### 数据集构建

#### GNN数据集构建

###### 基础数据集选择

常用的3d 模型数据集有：

- ModelNet：包括ModelNet10和ModelNet40，官网还提供了模型方向对齐的版本。但是模型数据很不规则，其中很多模型的部分是断裂的，大多数基于水密网格的算法并没有使用到这个数据集。

  <img src="https://raw.githubusercontent.com/poinne/md-pic/main/image-20241202103727110.png" alt="image-20241202103727110" style="zoom:50%;" />

  因此不选择这个。

- MSB(McGill 3D Shape Benchmark)：一共19个类，458个模型

  MSB中的一些模型与shrec16中的模型很像，模型通过ply格式保存，这个格式可扩展性更强，可以允许用户自定义属性。但是每个模型的顶点和面较多，并且没有顶点法向，如果用的话需要处理一下。

  <img src="https://raw.githubusercontent.com/poinne/md-pic/main/image-20241202110500768.png" alt="image-20241202110500768" style="zoom: 50%;" />

- shrec16：有30个类别，每个类别20个形状。比较常用的是MeshCNN所提供500个面的版本。（即laplacian论文模型使用的数据集），模型分辨率不够（相对于本课题），需要进行细分。

  <img src="https://raw.githubusercontent.com/poinne/md-pic/main/image-20241202110610444.png" alt="image-20241202110610444" style="zoom:50%;" />

选择shrec16数据集作为基础数据集，来构建本课题的数据集。

对于每个网格模型，生成10组控制条件，即每个网格生成10条数据。

数据集中的每条数据，包括网格，控制点，切线，初始水平集，优化后的水平集真值，heaviside值。

修改gegnn代码，首先对不迭代的方式进行训练，并修改模型和超参数，查看效果。

如果各种方式效果都不理想，就用GNN+RNN的方式。



**heaviside : **没有好的办法**判断顶点是否位于零水平集内**，因此现在初始的水平集用的是UDF，无法计算heavisde值，并且三角网格中**点和面是不规则的，计算出的heaviside是不准确的**。（虽然不准确，也可以用）

###### 模型训练效率提高

目前的效率很低，现在每个batch只有一个数据，训练一次需要35s，其中，计算微分算子需要15秒。主要原因是目前使用差分计算微分算子计算量大，导致计算和梯度反向传播都非常耗时。（如果使用微分算子，每次训练只需不到0.5s）

所以如果使用差分来计算微分算子的话，需要使用窄带加速来减少计算量，在卷积时使用所有的顶点，但是在计算损失函数时只对窄带区域上的顶点进行计算。（可以暂时先不做，可以先看有限元方法和GCN方法的精度和效率）

通过代码优化，现在的微分算子计算效率是可以的，训练一次1s左右，但是模型的光滑性损失不会下降（无论是用矩阵还是稀疏矩阵），原因可能是laplacian的计算没有进行反向传播，或者laplacian的计算就是错的。

通过调参发现，之前是interp 损失太高了，导致模型预测的增量很快降低到接近0，导致Laplacian 变化较小。并不是laplacian的问题。

![image-20241202232813136](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241202232813136.png)

但是现在虽然各项损失都会减少，但是从结果来看，训练后的模型水平集很乱，零水平集断断续续，看不出是一条曲线。所以可能是梯度的问题？毕竟梯度的实现可能是不对的。还可能是水平集的问题，因为这是直接预测的，而不是慢慢演化的，所以还需要一个可以保证零水平集存在的项，不知道loss_sdf项可不可以。

![image-20241202233316893](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241202233316893.png)



---

目前使用离散方式来近似损失函数中的梯度和拉普拉斯，并手动创建一个极小的数据集（10条数据，且用的都是一个网格模型）来进行无监督的训练。

每条数据训练5次后进行一个梯度更新，所有数据训练一遍为一个epoch。

但是现在可视化的中间过程保存的结果，发现隐式曲线并没有变光滑，且水平集会变得并不明显：

![image-20241212194116137](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241212194116137.png)

且当epoch增多时，会出现如下情况：

![image-20241212194030674](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241212194030674.png)

初步推断，可能由以下一种或几种情况引起：

（1） 数据集过小，模型无法学习到有效的信息。

数据集小时，模型更容易过拟合，至少对于一些中间的结果，可以得到一些相对于输出，较好的效果（比如曲线变的平滑）。但是现在并没有平滑的迹象。因此这个不是主要原因。暂时排除。

（2）所用的模型无法有效提取输入的特征并预测水平集

主要可能在池化模块，可能顶点在聚合后，并没有使用到水平集的信息？

或者是卷积模块，或者其它地方编码错误或没有修改？

（3）损失函数设计存在错误

光滑项计算或设计不对，导致不能对预测的结果进行光滑约束

现在的问题时，在训练时，随着训练次数的增加，因为光滑项使用了高斯核函数进行加权，导致模型预测的值会逐渐偏离0（高斯核函数在值为0处的值较大，偏离0后光滑项会更小），因此预测sdf的值逐渐增大，导致结果错误。

但是通过增大插值损失的权重保持插值点值为0时，光滑项的变化很小，插值损失只是计算几个插值点的sdf值，但是整个初始曲线上的所有点都会保持不变，从而导致曲率的变化很小。为什么会初始曲线的非插值点的变化很小？并没有损失项对其进行约束啊？

可能是拉普拉斯，对比几种方法



（4）微分算子计算错误

通过对比代码中近似结果与软件计算结果：

![image-20241212200712036](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241212200712036.png)

左侧为代码近似结果，右侧为paraview近似结果，可以看到近似结果与软件结果虽有较大差距，但是不会影响到光滑的约束（至少能起到作用），因此暂时排除微分算子的计算错误。

![image-20241213141329234](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213141329234.png)

![image-20241213141308374](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213141308374.png)



对比结果如下：

黄色：初始值

红色 ：540

紫色：800

黑色：1000

![image-20241213144539041](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213144539041.png)

![image-20241213145414842](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213145414842.png)

从对比图可以看出：

1. 虽然光滑性有所上升，但是对于插值点的预测并不完全正确。
2. 感觉有很多区域太'长',能否添加一个长度约束，或者通过更多次的迭代来优化？

所以从两个方面来尝试解决：

1.通过添加长度约束，来使零水平集更加光滑

2.修改近似拉普拉斯的公式

3.尝试更多次训练。



1. 添加长度约束的对比结果：

   蓝色：200

   黄色：280

   紫色：430

   ![image-20241213155147139](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213155147139.png)



棕色：1000

橙色：1500

白色：2000

绿色：2840

![image-20241213191829831](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213191829831.png)

可以看出，随着迭代次数的增加，效果并没有持续变好，

模型训练好后，每次推理的结果是一样的（如果输入一样的话）

只使用一条数据进行训练：

使用训练的数据进行推理：

![image-20241213195321087](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213195321087.png)

使用非训练的数据进行推理：

![image-20241213195230871](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241213195230871.png)



使用10条数据进行训练，推理结果如下：

iter : 2000

测试1：

![image-20241214111728838](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214111728838.png)

测试2：

![image-20241214111843000](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214111843000.png)

iter:1500

测试1：

![image-20241214112341963](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214112341963.png)

测试2：

![image-20241214112432571](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214112432571.png)

iter : 1000 

测试1：

![image-20241214112614302](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214112614302.png)

测试2：

![image-20241214112706336](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214112706336.png)

iter:800

测试1：

![image-20241214113026602](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214113026602.png)

测试2：

![image-20241214112958404](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214112958404.png)

![image-20241214113134055](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214113134055.png)

使用训练集数据进行测试：

![image-20241214114304023](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214114304023.png)

iter:800

![image-20241214114510809](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214114510809.png)



iter:2000

![image-20241214114626382](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214114626382.png)

![image-20241214114926339](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214114926339.png)



可以看出，对于训练集的数据，模型的预测结果和测试集的数据相似，并没有非常明显的区别（模型没有过拟合)

**曲线不光滑可能原因如下：**

1.网格的分辨率低，因为软件是计算出边上的零水平集，然后连接，导致不够光滑。

2.近似的拉普拉斯算子精度不够，导致模型训练过程的光滑性约束并不完全正确。

解决方法：

1.对使用网格进行细分，提高分辨率

2.修改近似的方法，尝试直接使用软件的接口，查看训练效果

**曲线不经过插值点原因可能如下：**

1.插值损失使用的是插值点处的平方和，因为本身插值点处的预测值就非常接近0，导致其平方和很小（小于1e-3），但预测值本身没有这么小。

2.因为模型属于一次预测，而不是迭代优化，会平衡损失函数中各项的约束，因此无法完全满足插值点约束。

解决方法：

1.增加插值点约束权重

2.后续用迭代训练的方式来进行预测（优化）



首先增加插值点约束权重，并且提高网格分辨率，进行训练：



TVCG论文的附录已经发表，实现附录中的梯度和拉普拉斯计算，但是使用论文中的梯度计算方法时，sdf损失变的非常大，导致网格上的水平集值会在训练过程中变的非常小，且接近0，导致网格上出现多条零水平集曲线。

因此梯度的近似暂时使用之前 in haet中提到的方法，拉普拉斯的近似则使用论文中的实现，对单个数据迭代训练效果如下：

iter：300

![image-20241214212840290](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214212840290.png)

iter：900

![image-20241214212919456](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214212919456.png)

iter：2000

![image-20241214212940214](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214212940214.png)

iter:3000

![image-20241214213008008](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214213008008.png)

iter:5000

![image-20241214215636452](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241214215636452.png)

使用同一个网格上的10条数据训练的结果如下：

训练集的结果如下：

![image-20241216100709667](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216100709667.png)

![image-20241216100634649](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216100634649.png)

![image-20241216100553276](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216100553276.png)

![image-20241216100825196](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216100825196.png)

测试集的结果如下：

![image-20241216101157731](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216101157731.png)

![image-20241216101256161](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216101256161.png)

![image-20241216103641216](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216103641216.png)

![image-20241216103731667](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216103731667.png)

![image-20241216103813446](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241216103813446.png)

现在得到的曲线还是不够光滑，目前通过提高光滑项权重和添加长度约束项来优化预测的曲线。但是在添加长度约束时出现问题，长度约束无法通过反向传播来更新（即无法起作用，试了多种方式，还是没有作用）

长度约束已经起作用了，之前不起作用主要是代码实现写错了。现在的结果如下（10条数据）

训练集：

![image-20241217131002012](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217131002012.png)

![image-20241217131047991](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217131047991.png)

![image-20241217131216575](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217131216575.png)

![image-20241217131259437](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217131259437.png)

![image-20241217131636369](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217131636369.png)

测试集：

![image-20241217130655203](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217130655203.png)

![image-20241217130728236](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217130728236.png)

![image-20241217130752097](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217130752097.png)

可以看到，在训练集上的结果的长度已经可以了，但是光滑度和插值相对较差，可以通过提高对应约束的权重或降低长度约束权重来进一步优化模型的生成结果。

但是在测试集的效果并不好，这还只是在同一个网格上训练的结果，如果使用多种网格或曲率变化较大的网格进行训练，结果可能会进一步变差。 

在使用大数据集进行训练之前，先使用小数据集进行障碍和切线约束的训练，测试并修改代码。

添加障碍后：

![image-20241217161953941](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217161953941.png)

![image-20241217191558608](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217191558608.png)

![image-20241217191609839](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241217191609839.png)

训练过程中的一些结果较好，但是也存在一些很差的结果，预测的结果并没有随着训练次数的提高的线性增长。（从图像上看）

---



通过按照论文附录的方法对近似的方法进行修改，在只使用插值约束和光滑约束的情况下，已经可以得到很好的结果，且只需200次左右迭代，但是当加入障碍约束后，在模型迭代次数多的时候，预测的结果会变差。

![image-20241220155756958](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241220155756958.png)

这里可能的原因有：

1. 网格的分辨率和approach生成使用的高斯核不匹配，导致生成的approach不对，进而导致障碍约束是错误的。
2. 障碍约束不对

通过检查障碍约束的代码，发现确实是代码的问题，修改过后，得到的结果如下：

![image-20241220170822186](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241220170822186.png)

![image-20241220170850265](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241220170850265.png)

对于单个数据已经可以得到较好的结果，现在测试在相同网格上的泛化能力：

（同一个网格，10条训练，4条测试）

对于多条数据的训练，结果并不理想，对于一些插值点接近边缘的数据，会出现如下情况：

![image-20241220203138889](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241220203138889.png)

这种情况在水密流形上应该可以避免。

其它的情况效果还可以，现在准备使用大的数据集进行训练（called：curvedata）。（150条数据，30个网格）

首先对curvedata中的一条数据进行训练，在得到一个好的结果后在对curvedata中的数据进行训练。

![image-20241222135119890](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222135119890.png)

![image-20241222134426812](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222134426812.png)

当迭代次数多时，会出现如上情况：

猜测可能原因如下：

模型分辨率低且曲面起伏大，导致曲率约束不能下降，进而模型通过寻找平滑的曲线来降低曲率约束项。

下面的两个方法的结果都是稳定之后（收敛？）的截图

1.提高模型分辨率

通过线性细分，得到顶点数4000左右的mesh（之前是1000），权重和下面的改变相同，结果如下：

![image-20241222142634180](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222142634180.png)

2.降低曲率项权重

通过降低曲率项的权重，并提高障碍点的权重，得到的结果如下：

![image-20241222142729137](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222142729137.png)

这两种方法都可以使效果更好，但是感觉分辨率高的网格生成的曲线更加光滑，并且在训练中可以很快地达到稳定（收敛？），因此可以测试两个方向：

1.低分辨率下的不同插值点的生成情况

当插值点距离较远且插值点所处位置的曲率变化较大时，会出现如下情况：

生成多条零水平集曲线。在高分辨率下也会出现相同的情况

![image-20241222144535460](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222144535460.png)

2.高分辨率下的生成情况(两个网格，6个数据)

**迭代2200次结果：**

![image-20241222194307084](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194307084.png)

![image-20241222194254677](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194254677.png)

![image-20241222194241514](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194241514.png)

![image-20241222194352935](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194352935.png)

![image-20241222194443712](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194443712.png)

上图的背面：

![image-20241222194506970](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194506970.png)

![image-20241222194544693](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222194544693.png)

测试结果：（同一个网格上的不同插值点）

![image-20241222195402070](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222195402070.png)

![image-20241222195436541](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222195436541.png)

![image-20241222195510920](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222195510920.png)

![image-20241222195625704](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222195625704.png)

**迭代1000次结果：**

![image-20241222202005336](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222202005336.png)

![image-20241222201952149](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222201952149.png)

![image-20241222202204431](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222202204431.png)

![image-20241222202228358](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222202228358.png)

![image-20241222202257755](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222202257755.png)

![image-20241222202351919](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241222202351919.png)

可以看到，在迭代次数较少时，虽然存在一些地方的不够光滑，但是曲线的拓扑是正确的，当迭代次数增多后，曲线更加接近椭圆，一些曲面的曲率较大的点可能会脱离原本的曲线，独自形成一个新的曲线。

尝试使用更多的数据进行训练，查看得到的结果已经测试结果：

1.增加batch的大小，批量训练

将代码修改为batch>1进行训练，但是训练的效率并没有显著提高（快接近一倍），但是存在很多问题，并且障碍不正确，

已经修改好批量处理的代码，现在可以进行大数据集的计算。

由于训练时间过长，为了尽快看到效果，使用2/3的数据进行训练，从一条数据的1600次预训练模型开始，10h迭代到2560次，得到的结果如下：

训练数据结果：

![image-20241224102303442](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102303442.png)

![image-20241224102354064](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102354064.png)

![image-20241224102420325](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102420325.png)

![image-20241224102450230](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102450230.png)

![image-20241224103447330](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103447330.png)

![image-20241224103425722](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103425722.png)

![image-20241224103519029](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103519029.png)

![image-20241224103604846](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103604846.png)

![image-20241224103647582](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103647582.png)

![image-20241224103654764](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224103654764.png)

在测试集上的结果：

![image-20241224102655776](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102655776.png)

![image-20241224102721490](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102721490.png)

![image-20241224102747022](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102747022.png)

![image-20241224102835041](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102835041.png)

![image-20241224102856714](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224102856714.png)

![image-20241224104021502](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104021502.png)

![image-20241224104132305](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104132305.png)

![image-20241224104253382](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104253382.png)

![image-20241224104311480](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104311480.png)

是一条曲线，且满足控制点约束，但是很绕



![image-20241224104431085](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104431085.png)

![image-20241224104515295](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224104515295.png)

可以看到，对于训练集上的数据，当某个点所处位置距其它点较远且局部的曲面变化较大时，仍会生成小环。但是在一般的情况下，生成的曲线已经较好。

对于测试集上的数据，对大部分情况已经可以满足控制点约束，但是光滑度较训练集的结果仍有差距，且当插值点和障碍点的距离较近时可能会出现多条曲线。

一个可能的原因是生成的approach数据的问题，因为插值点也使用了高斯核函数进行平滑，虽然在训练计算损失的过程中大于0的值被赋值为0，但是在测试时并没有这么做，从而导致生成的曲线会在插值点附近绕圈子。

修改生成数据，重新预测：（重新预测（白色））

![image-20241224125745174](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224125745174.png)

![image-20241224130151820](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224130151820.png)

对于修改过approach的数据，在插值点处会存在突起的情况。可能是因为预测的数据和训练用的数据的approach不同导致。**需要使用修改过的数据进行训练，然后预测。**（今天下午完成）

使用修改过的模型，对上面的2560次的预训练模型进行继续训练，在2900次时，查看结果：

在训练集上的结果应该不错，但是在测试集的结果，仍会出现如下图所示：

![image-20241224195731360](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224195731360.png)

![image-20241224200724579](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224200724579.png)

![image-20241224195137661](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224195137661.png)

原因大概率是障碍点距离插值点过近，导致插值点附近的点的approach值过小（< -0.5)，进而影响插值点约束。（可以从两个方面解决，修改高斯核的参数（修改障碍点的或者插值点的），或者限制插值点的位置）

![image-20241224195828690](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224195828690.png)

2.使用同一个模型的多条数据（100以上？）进行训练，测试是否可以使其具有较好的预测效果（找一种数据生成方式来生成数据）

暂时先用33条，可以再加几个，到50个左右（输入数据要求严格的话， 可能不需要太多就可以进行准确的预测了）

当使用修改过的数据进行测试的时，会出现如下所示的结果：

![image-20241224152614493](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241224152614493.png)

推测是由于修改后的approach在插值点附近都为0，导致曲线的不连续。

3.修改障碍点的高斯核生成部分

![image-20241223205015408](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241223205015408.png)

从这段话可以看出，论文中使用的方法设置的高斯核为窄带的宽度，即2倍的平均边长。（这样的话，要求障碍点距离最近的插值点要在二环邻域之外，否则就会受到影响）

(修改之后可能出问题了，就是上面的问题)

经过老师指导，知道批量生成数据的方法：先生成模型的测地线，然后在测地线上进行插值点或障碍点的采样，同时，采样时可以引入随机性，在要采样点的邻域进行采样。

在迭代到3400次后，生成的曲线形状基本稳定，但是预测集的结果如下：

![image-20241225145811611](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241225145811611.png)

![image-20241225150019526](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241225150019526.png)

在相邻两个插值点之间的曲线光滑性相对较好，但是相邻的两段曲线会有较大区别，并不能平滑的连接。

测试集预测出的零水平集可能过长：

![image-20241225150206316](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241225150206316.png)

构造了一个1200条数据的数据，通过等值线来确定取点的范围，但是由于模型存在很多肢体，因此选择的点仍感觉不好。由于1200条数据训练时间过长，暂时取400条数据在之前训练的基础上训练。（3720~3900）由于新生成的训练集的点的选择存在随机性，因此查看3900次训练的结果，效果很差，但是用3900次的模型来预测之前的数据，效果却比3720次好的多，对插值和障碍的拟合很好，只是光滑性不足。猜测是之前人工构造的数据集存在主观性，而新生成的数据集由于随机生成的原因，导致数据的分布较为平均，且新数据集的数据较多（之前是80，现在是400），因此模型的效果进一步提升，而在训练集上的效果不好，一是在新的数据集上只训练了180个epoch，还没有完全学到新数据集的特征，二是新数据集的控制点分布可能均匀，一些点可以分布的较远，或在一些肢体上，因此效果不好。

3900次训练，预测的效果如下，浅蓝色为3700（即用80条数据），深蓝色为3900（新训练的）

![image-20241227152256688](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227152256688.png)

![image-20241227152318814](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227152318814.png)

对于控制点相距较近的情况，也可以很好的预测：

![image-20241227152345246](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227152345246.png)

![image-20241227152516460](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227152516460.png)

![image-20241227210339911](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227210339911.png)

![image-20241227210400183](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227210400183.png)

![image-20241229111259289](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229111259289.png)

![image-20241227210418594](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227210418594.png)

但是仍然存在有多个环的情况：

![image-20241227210434865](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227210434865.png)

以及在某些点处不够光滑的情况：

![image-20241227210524973](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227210524973.png)

![image-20241227210903275](../../AppData/Roaming/Typora/typora-user-images/image-20241227210903275.png)

其它网格的泛化效果：

![image-20241227222539113](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227222539113.png)

![image-20241227222556635](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227222556635.png)

![image-20241227222612483](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227222612483.png)

![image-20241227222626258](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241227222626258.png)

控制点拟合的很好，但是光滑度明显不足

当训练所用的网格增大后，训练所用的时间（主要是反向传播）会明显增大，导致训练非常耗时, 通过以下方式来进行训练，由于神经网络对输入网格的顶点数没有要求，可以先使用小网格数据集进行训练，有效果后再使用大网格数据集，并且可以先使用少量数据训练，之后再使用全部数据继续训练。

考虑到训练过慢，尝试在低分辨率网格上进行训练，然后在使用高分辨率网格进行测试，查看效果，如果区别不大的话， 就使用低分辨率进行训练。

当前的效果如下：（测试数据为18个，在16个数据都有较好的效果，其余两个则存在插值点处测地曲率过大，未经过插值点的问题）

![image-20241229164830041](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229164830041.png)

![image-20241229164952463](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229164952463.png)

![image-20241229165010355](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165010355.png)

![image-20241229165032530](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165032530.png)

![image-20241229165231978](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165231978.png)

曲线更倾向于经过插值点的外侧，而不是从内侧经过：

![image-20241229165257854](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165257854.png)

差的情况：

![image-20241229165101802](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165101802.png)

![image-20241229165135101](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241229165135101.png)



训练步骤：

使用手动构造的数据集的单个数据进行训练。作为baseline1

使用手动构造的数据集的10个数据在baseline1上进行训练。作为baseline2

使用手动构造的数据集的80个数据在baseline2上进行训练。作为baseline3

使用生成的数据集的400个数据在baseline3上进行训练。作为baseline4

使用生成的数据集的1000个数据在baseline4上进行训练。得到最终的预训练模型。



现在的效果：

1. 对于测试集，大部分情况都可以很好的预测，但是仍存在一些插值点处不光滑的情况
2. 对于其它和数据集差距较大的网格 的预测，光滑度明显不足，但是对于控制点的预测较好。会出现没有零水平集的预测情况。

1.对于模型训练的时间较长的问题，考虑使用其它模型（但是当前的模型并没有特征复杂，使用其它模型进行训练可能训练时间也很久）。或者使用上述的训练策略，训练集由小到大，逐步训练。

2.当前模型对于插值和障碍点的预测已经较好，光滑度基本可以。考虑添加其它约束（论文中的切线和拓扑约束）

问一下老师，切线约束是不是局限于插值点上的，

在计算损失时，首先遍历出存在几个切线点的面，对于每个切线点，遍历其一邻域的面，进行计算，得到对应切线点的梯度。求对应点的切线**点积**的二次能量，作为切线损失。