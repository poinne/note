#### 研究方案及可行性分析

##### 研究方案

给定一个输入网格：$M = \{V,F\}$，其中$V$ 和 $F$ 分别表示网格的顶点和面的几何，给定约束条件，首先通过预处理将约束条件转换为定义在顶点上的约束向量，并生成初始水平集函数，与顶点的坐标和法向一起作为顶点的输入向量。

模型1为图神经网络结合循环神经网络，利用循环神经网络进行迭代优化网格上的水平集函数，在每次迭代过程中，通过图神经网络聚合各个顶点的信息，提取关键特征并预测水平集增量，通过损失函数来优化模型参数和网格水平集函数。

训练完成后，模型需T次前向迭代过程得到最终满足约束的水平集函数增量进而提取出目标曲线。

模型2为图神经网络，在训练过程中，对于每条输入数据（三角网格和约束条件），都有事先准备的水平集真值，对于每条数据，不需要迭代训练，优化水平集函数值，而是只通过一次前向过程，将预测结果作为最终的水平集函数，损失函数和model1的损失函数类似，但是额外添加了真值项和heaviside项，以进一步提高模型预测的准确度。

训练完成后，模型仅需一次前向过程即可预测满足约束的水平集函数增量。进行得出新的水平集函数值。

**输入的预处理：**

输入特征包括网格的几何特征以及根据外部约束构造的特征。

网格的几何特征包括：顶点坐标以及顶点的法向。

外部约束包括插值点：$V_{interp}$、障碍点：$V_{obs}$，以及指定点的法向，首先根据插值点，利用广度优先遍历算法，得到经过插值点、连接网格的边且无自交的闭环。通过fast marching 算法生成初始的符号距离场。

其中:

![image-20241120154829171](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241120154829171.png)

为了使模型在进行卷积提取顶点特征时能够考虑到外部的约束条件，通过高斯核函数结合插值和障碍约束，将外部约束条件转换为定义在顶点上的标量值，称为趋近值，对于插值点，趋近值设为1，对于障碍点，趋近值为-1，其余顶点的趋近值通过高斯核函数平滑得到。

![image-20241120172211249](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241120172211249.png)

指定顶点的切法向：$list:(a_1,a_2...), a_i = \{v_i,n_i\}$，同样作为顶点的三维向量，未指定区域为（0，0，0）

对于每个顶点，其输入的向量为$(position, normal, sdf, approach, tangential)$,共11维。

**模型架构**

![image-20241120135548751](https://raw.githubusercontent.com/poinne/md-pic/main/image-20241120135548751.png)

模型架构为Unet结构，使用Unet架构，结合残差连接可以更好地提取网格的顶点特征，并且多层次的架构对质量较差或接近退化的网格同样有一定的预测能力【】其中卷积模块为图卷积：
$$
F'_i = W_0 \times \mathcal{A}_{j \in \mathcal{N}(i)}(W_1 \times [F_j||v_{ij}||l_{ij}||sdf_{ij}||approach_{ij}||tangential]) \\
\mathcal{A} : max、mean、sum
$$
聚合算子使用max（？）

池化模块会同时考虑顶点的坐标和法向来进行顶点的聚合，顶点的法向可以防止薄面两侧的顶点被聚合。

同时会跟踪池化操作前后顶点之间的映射关系，用于上采样时顶点以连接关系的恢复。

顶点特征在通过Unet结构卷积之后，会通过MLP得到预测的sdf增量，通过与初始的sdf值进行相加，得到预测的sdf值。

**损失函数：**

水平集函数为：
$$
loss  = E_{sdf} + \lambda_1E_{shape} +\lambda_2E_{topology}
$$
符号距离约束：

$E_{sdf}$：$E_{eikonal} = \int_M\frac{1}{2}(|\nabla\phi_i|^2 - 1)^2dM$ ， 用于控制预测的水平集值的稳定性，防止标量场太陡或太平。

$E_{shape} = w_{interp}E_{interp}(\phi) + w_{obs}E_{obs}(\phi) + w_{smooth}E_{smooth}(\phi) + w_{tan}E_{tan}(\phi)$

形状约束分为内部约束和外部约束：

内部约束：

光滑性约束：$E_{smooth} = \int_{M}|\nabla\phi_i|div(\frac{\nabla\phi_i}{|\nabla\phi_i|})\delta(\phi)dM$ ， 用于控制零水平集构成的曲线的光滑性。其中，$\delta$ 为狄拉克函数，将所有非零的水平集点加权为零。

外部约束：

插值点约束：$L_{interp} = \sum^{I}_{p}(\phi_i(x_p))$，I为插值点数量，$x_p$是插值点

障碍点约束：$L_{obs} = - \sum^{O}_{p}(\phi_i(x_p))$ ，O为障碍点数量，$x_p$是障碍点

切线约束：$L_{tan} = \sum^{M}_{p}<\nabla\phi(x_p),\tau_p>$,M为插值点数量，$x_p$是插值点，$\tau_p$是插值点对应的输入切向量。

拓扑约束：
$$
E_{topology} = E_{noise} + E_{significant}\\
E_{noise} = \sum^N_{i = 1}b_i + \sum^N_{j = 1}(d_j - b_j),(b,d) \in 1-PD\\
E_{significant} = - \sum^S_{i = 1}(d_i - b_i) + \sum^N_{j = 1}(d_j - b_j),(b,d) \in 1-PD\\
$$


因为损失函数中包含水平集的梯度和拉普拉斯，在计算损失函数前需要先计算这些微分算子。

**微分算子的计算：**

使用训练好的GCN近似这些微分算子。

构造定义在mesh上的标量场，使用有限元得到对应的梯度场和拉普拉斯场作为ground true，通过有监督训练，训练IsoGCN，得到对应的模型近似对应的微分算子：

根据水平集值预测对应梯度场：$IsoGCN_{0 \rightarrow 1}$

根据水平集值预测对应拉普拉斯场：$IsoGCN_{0 \rightarrow 1 \rightarrow 0}$

精度高，速度比有限元快。保证等方差变换，泛化能力强。（对于输入的一些变换，输入不变或等变）可以处理不完整的网格（？）

根据得到的微分算子计算损失函数，通过pytorch框架的自动微分计算损失函数的求导，并进行梯度反向传播更新模型参数。

模型输出零水平集顶点满足条件的曲线通过水平集函数隐式表示，可通过marching  cubes算法提取出来

模型预测

给定mesh网格、插值点序列、障碍点序列、顶点及预期切线序列，通过预处理操作得到输入的顶点特征向量，输入训练好的模型，通过一次前向过程，得到预测的水平集值，之后可以通过零水平集提取算法得到预测的曲线。

##### 可行性分析

