### [2374. 边积分最高的节点](https://leetcode.cn/problems/node-with-highest-edge-score/)

给你一个有向图，图中有 `n` 个节点，节点编号从 `0` 到 `n - 1` ，其中每个节点都 **恰有一条** 出边。

图由一个下标从 **0** 开始、长度为 `n` 的整数数组 `edges` 表示，其中 `edges[i]` 表示存在一条从节点 `i` 到节点 `edges[i]` 的 **有向** 边。

节点 `i` 的 **边积分** 定义为：所有存在一条指向节点 `i` 的边的节点的 **编号** 总和。

返回 **边积分** 最高的节点。如果多个节点的 **边积分** 相同，返回编号 **最小** 的那个。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/06/20/image-20220620195403-1.png)

```
输入：edges = [1,0,0,0,0,7,7,5]
输出：7
解释：
- 节点 1、2、3 和 4 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 + 3 + 4 = 10 。
- 节点 0 有一条指向节点 1 的边，节点 1 的边积分等于 0 。
- 节点 7 有一条指向节点 5 的边，节点 5 的边积分等于 7 。
- 节点 5 和 6 都有指向节点 7 的边，节点 7 的边积分等于 5 + 6 = 11 。
节点 7 的边积分最高，所以返回 7 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/06/20/image-20220620200212-3.png)

```
输入：edges = [2,0,0,2]
输出：0
解释：
- 节点 1 和 2 都有指向节点 0 的边，节点 0 的边积分等于 1 + 2 = 3 。
- 节点 0 和 3 都有指向节点 2 的边，节点 2 的边积分等于 0 + 3 = 3 。
节点 0 和 2 的边积分都是 3 。由于节点 0 的编号更小，返回 0 。
```

 

**提示：**

- `n == edges.length`
- `2 <= n <= 105`
- `0 <= edges[i] < n`
- `edges[i] != i`



解：

一时间不知道要怎么做了，只能用笨方法，设个数组把每个节点的入度放进去，然后再遍历输出度最大的节点了。

第一次的代码：

```c++
class Solution {
public:
    int edgeScore(vector<int>& edges) {
        int len = 1e5 + 1;
        long long score[len];
        for (int i = 0; i < len; i ++)
        {
            score[i] = 0;
        }
        int length = edges.size();
        for (int i = 0; i < length; i ++)
        {
            score[edges[i]] += i;
        }
        int maxIdx = -1;
        long long maxValue = 0;
        for (int i = 0; i < len; i ++)
        {
            if (maxValue < score[i])
            {
                maxValue = score[i];
                maxIdx = i;
            }
        }
        return maxIdx;
    }
};
```

笑死了，本来想着开了个1e5的long long数组，内存占用肯定贼高，结果：

![image-20240921113528913](C:\Users\YS\Desktop\note\image_list\typora-image\image-20240921113528913.png)



题解用的方法和我的大致一样，只是将数组换成了vector，但是结果内存占用高了很多，应该是vector里一些维护指针的变量导致的。所以直接设一个大数组在节点和边数量级不高的情况下还是挺好用的，如果节点和边多的时候就要用vector了，因为没有那么大的连续内存用。

![image-20240921114719319](C:\Users\YS\Desktop\note\image_list\typora-image\image-20240921114719319.png)

题解：

```c++
class Solution {
public:
    using ll = long long;
    int edgeScore(vector<int>& edges) {
        int n = edges.size();
        vector<ll> points(n);
        for (int i = 0; i < n; i++) {
            points[edges[i]] += i;
        }
        ll max_points = -1;
        int res = -1;
        for (int i = 0; i < n; i++) {
            if (points[i] > max_points) {
                max_points = points[i];
                res = i;
            }
        }
        return res;
    }
};

```







