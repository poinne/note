### [1014. 最佳观光组合](https://leetcode.cn/problems/best-sightseeing-pair/)

给你一个正整数数组 `values`，其中 `values[i]` 表示第 `i` 个观光景点的评分，并且两个景点 `i` 和 `j` 之间的 **距离** 为 `j - i`。

一对景点（`i < j`）组成的观光组合的得分为 `values[i] + values[j] + i - j` ，也就是景点的评分之和 **减去** 它们两者之间的距离。

返回一对观光景点能取得的最高分。

 

**示例 1：**

```
输入：values = [8,1,5,2,6]
输出：11
解释：i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
```

**示例 2：**

```
输入：values = [1,2]
输出：2
```

 

**提示：**

- `2 <= values.length <= 5 * 104`
- `1 <= values[i] <= 1000`



解：

我一开始想的是，既然得分是数值与下标的组合，那我先处理下标，之后只需找出两个数值最大的数就行了。

对下标的处理：使数组中的每个元素减去对应的下标，但是因为得分中 i 的下标是加上的，而不是减去，所以最后还要判断i，并加上两倍的i。因为0的倍数都是0，所以还要特判一下0【其它的情况还没想到。。。】很麻烦

原代码：

```c++
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& values) {
        int first = 0, second = 0;
        int first_idx = 0, second_idx = 0;
        int len = values.size();
        for (int i = 0; i < len; i ++)
        {
            int t = values[i] - i;
            if (t >= first)
            {
                second = first;
                second_idx = first_idx;
                first = t;
                first_idx = i;
            }
            else if (t >= second)
            {
                second = t;
                second_idx = i;
            }
        }
        int res = first_idx < second_idx ? first_idx : second_idx;
        res = res * 2 + first + second;
        return res;
    }
};
```

到最后也没有ac，只过了一半用例。



看了题解才明白这道题要怎么做：

遍历数组，每一项作为j，此时values[j] - j 是固定的，因此只需找到j前面最大的values[i] + i 即可，因为对于j和i的判断是同时进行的（在一个for中），因此时间复杂度只有O(n)

代码：

```c++
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& values) {
        int res = 0, max_pre = values[0] + 0, len = values.size();
        for (int i = 1; i < len; i ++)
        {
            res = max(res, max_pre + values[i] - i);
            max_pre = max(max_pre, values[i] + i);
        }
        return res;
    }
};
```

